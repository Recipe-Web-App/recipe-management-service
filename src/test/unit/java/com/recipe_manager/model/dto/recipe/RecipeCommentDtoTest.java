package com.recipe_manager.model.dto.recipe;

import static org.assertj.core.api.Assertions.assertThat;

import java.time.LocalDateTime;
import java.util.UUID;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;

@Tag("unit")
class RecipeCommentDtoTest {

  @Test
  @DisplayName("All-args constructor assigns all fields")
  @Tag("standard-processing")
  void allArgsConstructorAssignsFields() {
    Long commentId = 1L;
    Long recipeId = 2L;
    UUID userId = UUID.randomUUID();
    String commentText = "Great recipe!";
    Boolean isPublic = true;
    LocalDateTime createdAt = LocalDateTime.now();
    LocalDateTime updatedAt = LocalDateTime.now();

    RecipeCommentDto dto =
        new RecipeCommentDto(commentId, recipeId, userId, commentText, isPublic, createdAt, updatedAt);

    assertThat(dto.getCommentId()).isEqualTo(commentId);
    assertThat(dto.getRecipeId()).isEqualTo(recipeId);
    assertThat(dto.getUserId()).isEqualTo(userId);
    assertThat(dto.getCommentText()).isEqualTo(commentText);
    assertThat(dto.getIsPublic()).isEqualTo(isPublic);
    assertThat(dto.getCreatedAt()).isEqualTo(createdAt);
    assertThat(dto.getUpdatedAt()).isEqualTo(updatedAt);
  }

  @Test
  @DisplayName("No-args constructor sets defaults and nulls")
  @Tag("standard-processing")
  void noArgsConstructorSetsDefaults() {
    RecipeCommentDto dto = new RecipeCommentDto();

    assertThat(dto.getCommentId()).isNull();
    assertThat(dto.getRecipeId()).isNull();
    assertThat(dto.getUserId()).isNull();
    assertThat(dto.getCommentText()).isNull();
    assertThat(dto.getIsPublic()).isNull();
    assertThat(dto.getCreatedAt()).isNull();
    assertThat(dto.getUpdatedAt()).isNull();
  }

  @Test
  @DisplayName("Builder sets fields correctly")
  @Tag("standard-processing")
  void builderSetsFieldsCorrectly() {
    Long commentId = 1L;
    Long recipeId = 2L;
    UUID userId = UUID.randomUUID();
    String commentText = "Delicious!";
    Boolean isPublic = false;
    LocalDateTime createdAt = LocalDateTime.now();
    LocalDateTime updatedAt = LocalDateTime.now();

    RecipeCommentDto dto =
        RecipeCommentDto.builder()
            .commentId(commentId)
            .recipeId(recipeId)
            .userId(userId)
            .commentText(commentText)
            .isPublic(isPublic)
            .createdAt(createdAt)
            .updatedAt(updatedAt)
            .build();

    assertThat(dto.getCommentId()).isEqualTo(commentId);
    assertThat(dto.getRecipeId()).isEqualTo(recipeId);
    assertThat(dto.getUserId()).isEqualTo(userId);
    assertThat(dto.getCommentText()).isEqualTo(commentText);
    assertThat(dto.getIsPublic()).isEqualTo(isPublic);
    assertThat(dto.getCreatedAt()).isEqualTo(createdAt);
    assertThat(dto.getUpdatedAt()).isEqualTo(updatedAt);
  }

  @Test
  @DisplayName("Setters and getters work for all fields")
  @Tag("standard-processing")
  void settersAndGettersWork() {
    RecipeCommentDto dto = new RecipeCommentDto();
    Long commentId = 10L;
    Long recipeId = 20L;
    UUID userId = UUID.randomUUID();
    String commentText = "Amazing";
    Boolean isPublic = true;
    LocalDateTime createdAt = LocalDateTime.now();
    LocalDateTime updatedAt = LocalDateTime.now();

    dto.setCommentId(commentId);
    dto.setRecipeId(recipeId);
    dto.setUserId(userId);
    dto.setCommentText(commentText);
    dto.setIsPublic(isPublic);
    dto.setCreatedAt(createdAt);
    dto.setUpdatedAt(updatedAt);

    assertThat(dto.getCommentId()).isEqualTo(commentId);
    assertThat(dto.getRecipeId()).isEqualTo(recipeId);
    assertThat(dto.getUserId()).isEqualTo(userId);
    assertThat(dto.getCommentText()).isEqualTo(commentText);
    assertThat(dto.getIsPublic()).isEqualTo(isPublic);
    assertThat(dto.getCreatedAt()).isEqualTo(createdAt);
    assertThat(dto.getUpdatedAt()).isEqualTo(updatedAt);
  }

  @Test
  @DisplayName("Equals/hashCode/toString are generated by Lombok")
  @Tag("standard-processing")
  void equalsHashCodeToString() {
    UUID userId = UUID.randomUUID();
    LocalDateTime now = LocalDateTime.now();

    RecipeCommentDto dto1 =
        RecipeCommentDto.builder()
            .commentId(1L)
            .recipeId(2L)
            .userId(userId)
            .commentText("Test comment")
            .isPublic(true)
            .createdAt(now)
            .updatedAt(now)
            .build();

    RecipeCommentDto dto2 =
        RecipeCommentDto.builder()
            .commentId(1L)
            .recipeId(2L)
            .userId(userId)
            .commentText("Test comment")
            .isPublic(true)
            .createdAt(now)
            .updatedAt(now)
            .build();

    assertThat(dto1).isEqualTo(dto2);
    assertThat(dto1.hashCode()).isEqualTo(dto2.hashCode());
    assertThat(dto1.toString()).contains("Test comment");
  }

  @Test
  @DisplayName("Null handling for all fields")
  @Tag("error-processing")
  void nullHandlingForAllFields() {
    RecipeCommentDto dto = new RecipeCommentDto(null, null, null, null, null, null, null);

    assertThat(dto.getCommentId()).isNull();
    assertThat(dto.getRecipeId()).isNull();
    assertThat(dto.getUserId()).isNull();
    assertThat(dto.getCommentText()).isNull();
    assertThat(dto.getIsPublic()).isNull();
    assertThat(dto.getCreatedAt()).isNull();
    assertThat(dto.getUpdatedAt()).isNull();
  }

  @Test
  @DisplayName("Comment text handling works correctly")
  @Tag("standard-processing")
  void commentTextHandling() {
    RecipeCommentDto dto = new RecipeCommentDto();
    dto.setCommentText("This is a very long comment that contains multiple sentences.");

    assertThat(dto.getCommentText())
        .isEqualTo("This is a very long comment that contains multiple sentences.");
  }

  @Test
  @DisplayName("isPublic flag works correctly")
  @Tag("standard-processing")
  void isPublicFlagWorks() {
    RecipeCommentDto publicDto = RecipeCommentDto.builder().isPublic(true).build();
    assertThat(publicDto.getIsPublic()).isTrue();

    RecipeCommentDto privateDto = RecipeCommentDto.builder().isPublic(false).build();
    assertThat(privateDto.getIsPublic()).isFalse();
  }
}
